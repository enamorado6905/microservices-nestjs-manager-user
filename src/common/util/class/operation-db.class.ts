import { Model, QueryOptions, UpdateWriteOpResult } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { PaginationDto } from '../../dto/list/pagination.dto';
import { PaginationClass } from './pagination.class';
import { PaginateInterface } from '../../interfaces/paginated.interface';
import { DeleteGroupsResult } from '@nestjs/microservices/external/kafka.interface';
import { status } from '@grpc/grpc-js';
import {
  rpcExceptionCreatedData,
  rpcExceptionFindOne,
  rpcExceptionNoDataFound,
} from '../../errors/exception-errors';
import { RpcException } from '@nestjs/microservices';

/**
 * @Injectable() marks the class as a provider that can be managed by Nest IoC container.
 */
@Injectable()
export class OperationDB<T> {
  /**
   * The constructor initializes the service and mongoDb properties.
   * @param service - A Mongoose model instance representing a MongoDB collection.
   */
  constructor(private readonly service: Model<T>) {}

  /**
   * Creates new documents in the MongoDB collection represented by the service.
   * This function takes an array of documents or a single document and an optional
   * options object as inputs.
   *
   * @param {Array<T> | T} docs The documents to be created.
   * @param {object} [options] Optional settings.
   * @returns {Promise<T[] | T>} The created documents.
   *
   * @description The function supports two types of document creation:
   * 1. BULK: Multiple documents are created when `docs` is an array.
   * 2. SINGLE: A single document is created when `docs` is an object.
   *
   * @example usage:
   * create([{ name: 'doc1' }, { name: 'doc2' }]) // returns [{ name: 'doc1' }, { name: 'doc2' }]
   * create({ name: 'doc1' }) // returns { name: 'doc1' }
   */
  public async create(docs: Array<T> | T, options?: object): Promise<T[] | T> {
    const item = await this.mongoDbCreate(docs, options);

    if (!item) {
      throw new RpcException({
        message: rpcExceptionCreatedData(),
        code: status.INVALID_ARGUMENT,
      });
    }

    return item;
  }

  /**
   * Finds and paginates documents in the MongoDB collection represented by the service.
   * This function takes a PaginationDto object and an optional options object as inputs.
   *
   * @param {PaginationDto} paginationDto The pagination and query parameters.
   * @param {object} [options] Optional settings.
   * @returns {Promise<PaginateInterface<T>>} The paginated documents matching the query.
   *
   * @description The function retrieves documents based on the query, sort, select, and populate parameters in the PaginationDto.
   * It then paginates the results based on the page and limit parameters in the PaginationDto.
   *
   * @example usage:
   * find({ limit: 10, page: 1, query: { name: 'doc1' } }) // returns first 10 documents with name 'doc1'
   */
  public async find(
    paginationDto: PaginationDto,
    options?: any,
  ): Promise<PaginateInterface<T>> {
    const data = await this.mongoDbFind(
      paginationDto.limit,
      paginationDto.page,
      paginationDto.query,
      paginationDto.select,
      paginationDto.sort,
      paginationDto.populate,
      options,
    );
    const paginated = new PaginationClass(
      paginationDto.page,
      paginationDto.limit,
      data,
      await this.mongoDbCount(),
    );
    return paginated.paginated();
  }

  /**
   * Finds a document in the MongoDB collection represented by the service by its ID.
   * This function takes an ID and returns the document with the matching ID.
   *
   * @param {string | number} id The ID of the document to find.
   * @returns {Promise<T | null>} The document with the matching ID, or null if no document was found.
   *
   * @description The function retrieves a document based on the provided ID.
   * If no document is found, it throws an error with a status of NOT_FOUND and a message generated by rpcExceptionNoDataFound(id).
   *
   * @example usage:
   * findById('60d5ecb8b392d7881236a610') // returns document with ID '60d5ecb8b392d7881236a610'
   * findById(123) // returns document with ID 123
   */
  public async findById(id: string | number): Promise<T | null> {
    // find item for id
    const item = await this.mongoDbFindById(id);

    // Check if found item exists
    if (!item) {
      throw new RpcException({
        message: JSON.stringify({
          message: rpcExceptionNoDataFound(id),
          code: status.NOT_FOUND,
        }),
      });
    }

    // return item
    return item;
  }

  /**
   * Finds the first document in the MongoDB collection represented by the service that matches the provided query.
   * This function takes a query object and returns the first document that matches the query.
   *
   * @param {object} filter The MongoDB query to execute.
   * @returns {Promise<T | null>} The first document matching the query, or null if no document was found.
   *
   * @description The function retrieves a document based on the provided query.
   * If no document is found, it throws an error with a status of NOT_FOUND and a message generated by rpcExceptionNoDataFound(query).
   *
   * @example usage:
   * findOne({ name: 'doc1' }) // returns the first document with name 'doc1'
   */
  public async findOne(filter: object): Promise<T | null> {
    const item = await this.mongoDbFindOne(filter);

    if (!item) {
      throw new RpcException({
        message: JSON.stringify({
          message: rpcExceptionFindOne(),
          code: status.NOT_FOUND,
        }),
      });
    }

    return item;
  }

  /**
   * Updates documents in the MongoDB collection represented by the service that match the provided filter.
   * This function takes a filter object and an update object as inputs.
   *
   * @param {object} id The filter used to select the documents to update.
   * @param {object} data The modifications to apply.
   * @returns {Promise<UpdateWriteOpResult>} The result of the update operation.
   *
   * @description The function updates documents in the MongoDB collection that match the provided filter.
   * The update is applied to all documents that match the filter.
   *
   * @example usage:
   * update({ name: 'doc1' }, { $set: { name: 'doc2' } }) // updates the name of all documents with name 'doc1' to 'doc2'
   */
  public async update(id: string, data: Partial<T>): Promise<T | null> {
    const item = await this.mongoDbFindByIdAndUpdate(id, data, {
      new: true,
    });

    if (!item) {
      throw new RpcException({
        message: JSON.stringify({
          message: rpcExceptionFindOne(),
          code: status.INVALID_ARGUMENT,
        }),
      });
    }

    return item;
  }

  /**
   * Updates a single document in the MongoDB collection represented by the service that matches the provided filter.
   * This function takes a filter object and an update object as inputs.
   *
   * @param {object} filter The filter used to select the document to update.
   * @param {object} data The modifications to apply.
   * @returns {Promise<UpdateWriteOpResult>} The result of the update operation.
   *
   * @description The function updates a single document in the MongoDB collection that matches the provided filter.
   * The update is applied to the first document that matches the filter.
   *
   * @example usage:
   * updateOne({ name: 'doc1' }, { $set: { name: 'doc2' } }) // updates the name of the first document with name 'doc1' to 'doc2'
   */
  public async updateOne(
    filter: object,
    data: Partial<T>,
  ): Promise<UpdateWriteOpResult> {
    const item = await this.mongoDbUpdateOne(filter, data, {
      new: true,
    });

    if (!item) {
      throw new RpcException({
        message: JSON.stringify({
          message: rpcExceptionFindOne(),
          code: status.INVALID_ARGUMENT,
        }),
      });
    }

    return item;
  }

  /**
   * Deletes a document by its ID from the MongoDB collection represented by the service.
   * This function takes an ID as input.
   *
   * @param {number | string} id The ID of the document to delete.
   * @returns {Promise<T | null>} The deleted document, or null if no document was found.
   *
   * @description The function deletes a document in the MongoDB collection by its ID.
   * If no document is found with the provided ID, it throws an error with a status of INVALID_ARGUMENT and a message generated by rpcExceptionFindOne().
   *
   * @example usage:
   * delete('1234abcd') // deletes the document with ID '1234abcd'
   */
  public async delete(id: number | string): Promise<T | null> {
    const item = await this.mongoDbFindByIdAndDelete(id);
    if (!item) {
      throw new RpcException({
        message: JSON.stringify({
          message: rpcExceptionFindOne(),
          code: status.INVALID_ARGUMENT,
        }),
      });
    }

    return item;
  }

  /**
   * Deletes the first document that matches the provided filter from the MongoDB collection represented by the service.
   * This function takes a filter object as input.
   *
   * @param {object} filter The filter used to select the document to delete.
   * @returns {Promise<DeleteGroupsResult>} The result of the delete operation.
   *
   * @description The function deletes the first document in the MongoDB collection that matches the provided filter.
   * If no document is found that matches the filter, it throws an error with a status of INVALID_ARGUMENT and a message generated by rpcExceptionFindOne().
   *
   * @example usage:
   * deleteOne({ name: 'doc1' }) // deletes the first document with name 'doc1'
   */
  public async deleteOne(filter: object): Promise<DeleteGroupsResult> {
    const item = await this.mongoDbRemoveOne(filter);

    if (!item) {
      throw new RpcException({
        message: JSON.stringify({
          message: rpcExceptionFindOne(),
          code: status.INVALID_ARGUMENT,
        }),
      });
    }

    return item;
  }

  /**
   * Counts the number of documents in the MongoDB collection represented by the service.
   *
   * @returns {Promise<number | null>} The number of documents in the collection.
   *
   * @description The function counts the number of documents in the MongoDB collection.
   * If an error occurs during the count operation, it throws an error with a status of INTERNAL and a message generated by rpcExceptionFindOne().
   *
   * @example usage:
   * count() // returns the number of documents in the collection
   */
  public async count(): Promise<number | null> {
    const item = await this.mongoDbCount();
    if (!item) {
      throw new RpcException({
        message: JSON.stringify({
          message: rpcExceptionFindOne(),
          code: status.INTERNAL,
        }),
      });
    }

    return item;
  }

  private async mongoDbFind(
    limit: number,
    skip: number,
    filter: object,
    select: string | string[] | Record<string, number | boolean | object>,
    sort: object,
    populate: {
      path?: string | string[];
      select?: string | any;
    } = {},
    options?: object,
  ): Promise<Array<T>> {
    let query = this.service.find(filter, options);

    if (select) {
      query = query.select(select);
    }

    if (sort) {
      query = query.sort(sort as any);
    }

    if (populate && populate.path) {
      query = query.populate(populate.path, populate.select) as any;
    }

    query = query.limit(limit).skip(skip);

    return await query;
  }

  private async mongoDbFindOne(
    conditions: object,
    projection?: object | string | Array<string>,
    select?: string | string[] | Record<string, number | boolean | object>,
    options?: object,
  ): Promise<T> {
    return await this.service
      .findOne(conditions, projection, options)
      .select(select);
  }

  private async mongoDbFindById(
    id: string | number,
    projection?: object | string | Array<string>,
    select?: string | string[] | Record<string, number | boolean | object>,
    options?: object,
  ): Promise<T> {
    return await this.service.findById(id, projection, options).select(select);
  }

  private async mongoDbFindByIdAndUpdate(
    id: string | object,
    update: object,
    select?: string | string[] | Record<string, number | boolean | object>,
    options?: object,
  ): Promise<T> {
    return await this.service
      .findByIdAndUpdate(id, update, options)
      .select(select);
  }

  private async mongoDbFindByIdAndDelete(
    id: number | string,
    select?: string | string[] | Record<string, number | boolean | object>,
    options?: QueryOptions,
  ): Promise<T> {
    return await this.service.findByIdAndDelete(id, options).select(select);
  }

  private async mongoDbCount(): Promise<number> {
    return await this.service.collection.countDocuments();
  }

  private async mongoDbCreate(
    docs: T | T[],
    options?: object,
  ): Promise<T[] | T> {
    return await this.service.create(docs, options);
  }

  private async mongoDbRemoveOne(
    filter: any,
    select?: string | string[] | Record<string, number | boolean | object>,
  ): Promise<DeleteGroupsResult> {
    return await this.service.deleteOne(filter).select(select);
  }

  private async mongoDbUpdateOne(
    filter: object,
    update: object | Array<object>,
    select?: string | string[] | Record<string, number | boolean | object>,
    options?: object,
  ): Promise<UpdateWriteOpResult> {
    return await this.service.updateOne(filter, update, options).select(select);
  }
}
